{"version":3,"file":"animations-async.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/animations/async/src/async_animation_renderer.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/packages/platform-browser/animations/async/src/providers.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  ɵAnimationEngine as AnimationEngine,\n  ɵAnimationRenderer as AnimationRenderer,\n  ɵAnimationRendererFactory as AnimationRendererFactory,\n} from '@angular/animations/browser';\nimport {\n  ɵAnimationRendererType as AnimationRendererType,\n  ɵChangeDetectionScheduler as ChangeDetectionScheduler,\n  inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgZone,\n  ɵNotificationSource as NotificationSource,\n  OnDestroy,\n  Renderer2,\n  RendererFactory2,\n  RendererStyleFlags2,\n  RendererType2,\n  ɵRuntimeError as RuntimeError,\n  type ListenerOptions,\n} from '@angular/core';\nimport {ɵRuntimeErrorCode as RuntimeErrorCode} from '../../../index';\n\nconst ANIMATION_PREFIX = '@';\n\n@Injectable()\nexport class AsyncAnimationRendererFactory implements OnDestroy, RendererFactory2 {\n  private _rendererFactoryPromise: Promise<AnimationRendererFactory> | null = null;\n  private scheduler: ChangeDetectionScheduler | null = null;\n  private readonly injector = inject(Injector);\n  private readonly loadingSchedulerFn = inject(ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN, {\n    optional: true,\n  });\n  private _engine?: AnimationEngine;\n\n  /**\n   *\n   * @param moduleImpl allows to provide a mock implmentation (or will load the animation module)\n   */\n  constructor(\n    private doc: Document,\n    private delegate: RendererFactory2,\n    private zone: NgZone,\n    private animationType: 'animations' | 'noop',\n    private moduleImpl?: Promise<{\n      ɵcreateEngine: (type: 'animations' | 'noop', doc: Document) => AnimationEngine;\n      ɵAnimationRendererFactory: typeof AnimationRendererFactory;\n    }>,\n  ) {}\n\n  /** @docs-private */\n  ngOnDestroy(): void {\n    // When the root view is removed, the renderer defers the actual work to the\n    // `TransitionAnimationEngine` to do this, and the `TransitionAnimationEngine` doesn't actually\n    // remove the DOM node, but just calls `markElementAsRemoved()`. The actual DOM node is not\n    // removed until `TransitionAnimationEngine` \"flushes\".\n    // Note: we already flush on destroy within the `InjectableAnimationEngine`. The injectable\n    // engine is not provided when async animations are used.\n    this._engine?.flush();\n  }\n\n  /**\n   * @internal\n   */\n  private loadImpl(): Promise<AnimationRendererFactory> {\n    // Note on the `.then(m => m)` part below: Closure compiler optimizations in g3 require\n    // `.then` to be present for a dynamic import (or an import should be `await`ed) to detect\n    // the set of imported symbols.\n    const loadFn = () => this.moduleImpl ?? import('@angular/animations/browser').then((m) => m);\n\n    let moduleImplPromise: typeof this.moduleImpl;\n    if (this.loadingSchedulerFn) {\n      moduleImplPromise = this.loadingSchedulerFn(loadFn);\n    } else {\n      moduleImplPromise = loadFn();\n    }\n\n    return moduleImplPromise\n      .catch((e) => {\n        throw new RuntimeError(\n          RuntimeErrorCode.ANIMATION_RENDERER_ASYNC_LOADING_FAILURE,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n            'Async loading for animations package was ' +\n              'enabled, but loading failed. Angular falls back to using regular rendering. ' +\n              \"No animations will be displayed and their styles won't be applied.\",\n        );\n      })\n      .then(({ɵcreateEngine, ɵAnimationRendererFactory}) => {\n        // We can't create the renderer yet because we might need the hostElement and the type\n        // Both are provided in createRenderer().\n        this._engine = ɵcreateEngine(this.animationType, this.doc);\n        const rendererFactory = new ɵAnimationRendererFactory(\n          this.delegate,\n          this._engine,\n          this.zone,\n        );\n        this.delegate = rendererFactory;\n        return rendererFactory;\n      });\n  }\n\n  /**\n   * This method is delegating the renderer creation to the factories.\n   * It uses default factory while the animation factory isn't loaded\n   * and will rely on the animation factory once it is loaded.\n   *\n   * Calling this method will trigger as side effect the loading of the animation module\n   * if the renderered component uses animations.\n   */\n  createRenderer(hostElement: any, rendererType: RendererType2): Renderer2 {\n    const renderer = this.delegate.createRenderer(hostElement, rendererType);\n\n    if ((renderer as AnimationRenderer).ɵtype === AnimationRendererType.Regular) {\n      // The factory is already loaded, this is an animation renderer\n      return renderer;\n    }\n\n    // We need to prevent the DomRenderer to throw an error because of synthetic properties\n    if (typeof (renderer as any).throwOnSyntheticProps === 'boolean') {\n      (renderer as any).throwOnSyntheticProps = false;\n    }\n\n    // Using a dynamic renderer to switch the renderer implementation once the module is loaded.\n    const dynamicRenderer = new DynamicDelegationRenderer(renderer);\n\n    // Kick off the module loading if the component uses animations but the module hasn't been\n    // loaded yet.\n    if (rendererType?.data?.['animation'] && !this._rendererFactoryPromise) {\n      this._rendererFactoryPromise = this.loadImpl();\n    }\n\n    this._rendererFactoryPromise\n      ?.then((animationRendererFactory) => {\n        const animationRenderer = animationRendererFactory.createRenderer(\n          hostElement,\n          rendererType,\n        );\n        dynamicRenderer.use(animationRenderer);\n        this.scheduler ??= this.injector.get(ChangeDetectionScheduler, null, {optional: true});\n        this.scheduler?.notify(NotificationSource.AsyncAnimationsLoaded);\n      })\n      .catch((e) => {\n        // Permanently use regular renderer when loading fails.\n        dynamicRenderer.use(renderer);\n      });\n\n    return dynamicRenderer;\n  }\n\n  begin(): void {\n    this.delegate.begin?.();\n  }\n\n  end(): void {\n    this.delegate.end?.();\n  }\n\n  whenRenderingDone?(): Promise<any> {\n    return this.delegate.whenRenderingDone?.() ?? Promise.resolve();\n  }\n\n  /**\n   * Used during HMR to clear any cached data about a component.\n   * @param componentId ID of the component that is being replaced.\n   */\n  protected componentReplaced(componentId: string) {\n    // Flush the engine since the renderer destruction waits for animations to be done.\n    this._engine?.flush();\n    (this.delegate as {componentReplaced?: (id: string) => void}).componentReplaced?.(componentId);\n  }\n}\n\n/**\n * The class allows to dynamicly switch between different renderer implementations\n * by changing the delegate renderer.\n */\nexport class DynamicDelegationRenderer implements Renderer2 {\n  // List of callbacks that need to be replayed on the animation renderer once its loaded\n  private replay: ((renderer: Renderer2) => void)[] | null = [];\n  readonly ɵtype = AnimationRendererType.Delegated;\n\n  constructor(private delegate: Renderer2) {}\n\n  use(impl: Renderer2) {\n    this.delegate = impl;\n\n    if (this.replay !== null) {\n      // Replay queued actions using the animation renderer to apply\n      // all events and properties collected while loading was in progress.\n      for (const fn of this.replay) {\n        fn(impl);\n      }\n      // Set to `null` to indicate that the queue was processed\n      // and we no longer need to collect events and properties.\n      this.replay = null;\n    }\n  }\n\n  get data(): {[key: string]: any} {\n    return this.delegate.data;\n  }\n\n  destroy(): void {\n    this.replay = null;\n    this.delegate.destroy();\n  }\n\n  createElement(name: string, namespace?: string | null) {\n    return this.delegate.createElement(name, namespace);\n  }\n\n  createComment(value: string): void {\n    return this.delegate.createComment(value);\n  }\n\n  createText(value: string): any {\n    return this.delegate.createText(value);\n  }\n\n  get destroyNode(): ((node: any) => void) | null {\n    return this.delegate.destroyNode;\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    this.delegate.appendChild(parent, newChild);\n  }\n\n  insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean | undefined): void {\n    this.delegate.insertBefore(parent, newChild, refChild, isMove);\n  }\n\n  removeChild(\n    parent: any,\n    oldChild: any,\n    isHostElement?: boolean | undefined,\n    requireSynchronousElementRemoval?: boolean,\n  ): void {\n    this.delegate.removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval);\n  }\n\n  selectRootElement(selectorOrNode: any, preserveContent?: boolean | undefined): any {\n    return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n  }\n\n  parentNode(node: any): any {\n    return this.delegate.parentNode(node);\n  }\n\n  nextSibling(node: any): any {\n    return this.delegate.nextSibling(node);\n  }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string | null | undefined): void {\n    this.delegate.setAttribute(el, name, value, namespace);\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string | null | undefined): void {\n    this.delegate.removeAttribute(el, name, namespace);\n  }\n\n  addClass(el: any, name: string): void {\n    this.delegate.addClass(el, name);\n  }\n\n  removeClass(el: any, name: string): void {\n    this.delegate.removeClass(el, name);\n  }\n\n  setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2 | undefined): void {\n    this.delegate.setStyle(el, style, value, flags);\n  }\n\n  removeStyle(el: any, style: string, flags?: RendererStyleFlags2 | undefined): void {\n    this.delegate.removeStyle(el, style, flags);\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    // We need to keep track of animation properties set on default renderer\n    // So we can also set them also on the animation renderer\n    if (this.shouldReplay(name)) {\n      this.replay!.push((renderer: Renderer2) => renderer.setProperty(el, name, value));\n    }\n    this.delegate.setProperty(el, name, value);\n  }\n\n  setValue(node: any, value: string): void {\n    this.delegate.setValue(node, value);\n  }\n\n  listen(\n    target: any,\n    eventName: string,\n    callback: (event: any) => boolean | void,\n    options?: ListenerOptions,\n  ): () => void {\n    // We need to keep track of animation events registred by the default renderer\n    // So we can also register them against the animation renderer\n    if (this.shouldReplay(eventName)) {\n      this.replay!.push((renderer: Renderer2) =>\n        renderer.listen(target, eventName, callback, options),\n      );\n    }\n    return this.delegate.listen(target, eventName, callback, options);\n  }\n\n  private shouldReplay(propOrEventName: string): boolean {\n    //`null` indicates that we no longer need to collect events and properties\n    return this.replay !== null && propOrEventName.startsWith(ANIMATION_PREFIX);\n  }\n}\n\n/**\n * Provides a custom scheduler function for the async loading of the animation package.\n *\n * Private token for investigation purposes\n */\nexport const ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN = new InjectionToken<<T>(loadFn: () => T) => T>(\n  typeof ngDevMode !== undefined && ngDevMode ? 'async_animation_loading_scheduler_fn' : '',\n);\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {\n  ANIMATION_MODULE_TYPE,\n  EnvironmentProviders,\n  makeEnvironmentProviders,\n  NgZone,\n  RendererFactory2,\n  ɵperformanceMarkFeature as performanceMarkFeature,\n  inject,\n} from '@angular/core';\nimport {ɵDomRendererFactory2 as DomRendererFactory2} from '../../../index';\n\nimport {AsyncAnimationRendererFactory} from './async_animation_renderer';\n\n/**\n * Returns the set of dependency-injection providers\n * to enable animations in an application. See [animations guide](guide/animations)\n * to learn more about animations in Angular.\n *\n * When you use this function instead of the eager `provideAnimations()`, animations won't be\n * rendered until the renderer is loaded.\n *\n * @usageNotes\n *\n * The function is useful when you want to enable animations in an application\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\n * providers returned by this function to the `providers` list as show below.\n *\n * ```ts\n * bootstrapApplication(RootComponent, {\n *   providers: [\n *     provideAnimationsAsync()\n *   ]\n * });\n * ```\n *\n * @param type pass `'noop'` as argument to disable animations.\n *\n * @publicApi\n *\n * @deprecated 20.2 Use `animate.enter` or `animate.leave` instead. Intent to remove in v23\n */\nexport function provideAnimationsAsync(\n  type: 'animations' | 'noop' = 'animations',\n): EnvironmentProviders {\n  performanceMarkFeature('NgAsyncAnimations');\n\n  // Animations don't work on the server so we switch them over to no-op automatically.\n  if (typeof ngServerMode !== 'undefined' && ngServerMode) {\n    type = 'noop';\n  }\n\n  return makeEnvironmentProviders([\n    {\n      provide: RendererFactory2,\n      useFactory: () => {\n        return new AsyncAnimationRendererFactory(\n          inject(DOCUMENT),\n          inject(DomRendererFactory2),\n          inject(NgZone),\n          type,\n        );\n      },\n    },\n    {\n      provide: ANIMATION_MODULE_TYPE,\n      useValue: type === 'noop' ? 'NoopAnimations' : 'BrowserAnimations',\n    },\n  ]);\n}\n"],"names":["AsyncAnimationRendererFactory","delegate","zone","animationType","moduleImpl","_rendererFactoryPromise","scheduler","loadingSchedulerFn","inject","ɵASYNC_ANIMATION_LOADING_SCHEDULER_FN","optional","_engine","ngOnDestroy","flush","loadFn","then","m","moduleImplPromise","catch","e","RuntimeError","ngDevMode","ɵcreateEngine","ɵAnimationRendererFactory","doc","rendererFactory","createRenderer","hostElement","rendererType","renderer","ɵtype","throwOnSyntheticProps","data","loadImpl","animationRendererFactory","animationRenderer","use","ChangeDetectionScheduler","notify","dynamicRenderer","begin","end","whenRenderingDone","Promise","resolve","componentReplaced","componentId","deps","target","i0","ɵɵFactoryTarget","Injectable","decorators","DynamicDelegationRenderer","replay","impl","fn","destroy","createElement","name","namespace","createComment","value","createText","destroyNode","appendChild","parent","newChild","makeEnvironmentProviders"],"mappings":";;;;;;;;;;;sBAgE2D,GAAA,GAAA;AAGvD,MAAKA,6BAAiB,CAAA;;EAgBpBC,QAAA;EACDC,IAAA;EAEDC,aAAA;EACGC,UAAA;AAnBJC,EAAAA,uBAAA,GAAA,IAAA;AAEDC,EAAAA,SAAA,GAAA,IAAA;;AAEGC,EAAAA,kBAAA,GAAAC,MAAA,CAAAC,qCAAA,EAAA;AACKC,IAAAA,QAAQ,EAAA;;EAE4EC,OAAA;iBAOlF,EACNV,QAA0B,EAC3BC,IAAA,EAEDC,aAAwB,EACrBC;YALK,MAAA;IACN,IAAAH,CAAAA,QAAiB,GAAjBA,QAAiB;IAClB,IAAAC,CAAAA,IAAA,GAAAA,IAAA;IAED,IAAAC,CAAAA,aAAwB,GAAxBA,aAAwB;IACrB,IAAAC,CAAAA,UAAQ,GAARA,UAAQ;AAMD;aAIgFQ,GAAA;AAW5F,IAAA,IAAC,CAAAD,OAAA,EAAAE,KAAA,EAAA;AAED;;AASE,IAAA,MAAAC,MAAc,GAAAA,MAAG,IAAI,CAACV,UAAuB,IAAA,OAAA,6BAA2B,CAAC,CAAAW,IAAA,CAAAC,CAAA,IAAAA,CAAA,CAAA;yBAGR;IAC/D,IAAA,IAAA,CAAAT,kBAAgB,EAAA;uBACjB,GAAA,IAAA,CAAAA,kBAAA,CAAAO,MAAA,CAAA;WAEsF;MACvFG,iBAA4B,GAAAH;AACzB;WAGyFG,iBAAA,CAC5FC,KAAA,CAAMC;AAEN,MAAA,MAA0F,IAAAC,aAAA,CAAA,IAAA,EAE1F,CAAA,OAAgBC,SAAM,KAAE,WAAC,IAAYA,SAAU,KAC7C,2CAAoC,GACrC,8EAAA,GAE2B,oEAAA,CAC1B;OAKEN,IAAA,CAAA,CAAA;MAAAO,aAAe;AAACC,MAAAA;AAAuB,KAAA,KAAA;AAGzC,MAAA,IAAE,CAAAZ,OAAA,GAAAW,aAAA,CAAA,IAAA,CAAAnB,aAAA,EAAA,IAAA,CAAAqB,GAAA,CAAA;AACD,MAAA,MAAAC,eAAY,GAAA,IAAAF,yBAAA,KAC4C,CAAAtB,QAAA,EACvD,IAAA,CAAAU,OAAA,EACA,IAAC,CAAAT,IAAA,CAEL;MACD,IAAA,CAAAD,QAAA,GAAAwB,eAAA;AAEI,MAAA,OAAAA,eAAA;AACH,KAAA,CAAA;;EAcCC,cAAAA,CAAAC,WAAA,EAAAC,YAAA,EAAA;IACO,MAAAC,QAAA,GAAiB,IAAoB,CAAA5B,QAAA,CAAAyB,cAAA,CAAAC,WAAA,EAAAC,YAAA,CAAA;IAE7C,IAAAC,QAAsB,CAAAC,KAAA,KAAA,CAAA,EAAA;AAEvB,MAAA,OAAAD,QAAA;;;cAhJQ,CAAAE,qBAAA,GAAA,KAAA;;;IAwJT,IAAuFH,YAAA,EAAAI,IAAA,GAAA,WAAA,CAAA,IAAA,CAAA,IAAA,CAAA3B,uBAAA,EAAA;AACzE,MAAA,IAAA,CAAAA,uBAAgD,GAAA,IAAA,CAAA4B,QAAA,EAAA;AACrD;QAEW,CAAQ5B,uBAAA,EAAeU,IAAA,CAAAmB,wBAAA,IAAA;MAEvC,MAAeC,iBAAA,GAAAD,wBAAA,CAAAR,cAAA,CACjBC,WAAa,EAEbC,YAAS;qBAE8D,CAAAQ,GAAA,CAAAD,iBAAA,CAAA;AACrE,MAAA,IAAA,CAAA7B,cAAa,aAAe,IAAG,CAAA+B,yBAAA,EAAA,IAAA,EAAA;AAAA3B,QAAAA,QAAA,EAAA;AAAA,OAAA,CAAA;oBACtB,EAAC4B,MAAC,CAAA,EAAA,CAAA;YAEX,CAAyDnB,CAAA,IAAA;AAEzDoB,MAAAA,eAAW,CAAGH,GAAA,CAAAP,QAAK,CAAA;MACrB;AAGF,IAAA,OAAQU,eAAA;AACN;OAGKC,GAAA;AACL,IAAA,IAAA,CAAAvC,QAAK,CAAAuC,KAAS,IAAK;AACnB;KAGWC,GAAA;QACX,CAAOxC,QAAA,CAAAwC,GAAK,IAAA;;mBAIDC,GAAA;IACb,OAAC,IAAA,CAAAzC,QAAA,CAAAyC,iBAAA,IAAA,IAAAC,OAAA,CAAAC,OAAA,EAAA;AAED;AAQWC,EAAAA,iBAA2BA,CAAAC,WAAA,EAAA;AAEtC,IAAA,IAAC,CAAAnC,OAAA,EAAAE,KAAA,EAAA;AAED,IAAA,IAAA,CAAAZ,QAAoF,CAAA4C,iBAAA,GAAAC,WAAA,CAAA;AAClF;;;;;UA1KK9C,6BAAiB;IAAA+C,IAAA,EAAA,SAAA;AAAAC,IAAAA,MAAA,EAAAC,EAAA,CAAAC,eAAA,CAAAC;AAAA,GAAA,CAAA;;;;;AAAjBnD,IAAAA,IAAAA,EAAAA;AAAiB,GAAA,CAAA;;;;;;QAAjBA,6BAAiB;EAAAoD,UAAA,EAAA,CAAA;;;;;;;;;;;;;;;AAwLvB,MAAAC,yBAAA,CAAA;EAOqBpD,QAAA;AAJbqD,EAAAA,MAAA,GAA+B,EAAA;EACvCxB,KAAA,GAAA,CAAA;cAGqB7B,QAAa,EAAA;IAAb,IAAAA,CAAAA,WAAAA;AAAa;AAGnCmC,EAAAA,GAAAA,CAAAmB,IAAsB,EAAA;IACpB,IAAA,CAAAtD,QAAK,GAAAsD,IAAS;AAGhB,IAAA,IAAA,IAAA,CAAAD,MAAe,KAAU,IAAY,EAAE;AAI/B,MAAA,KAAA,MAAUE,EAAY,IAAA,IAAA,CAAAF,MAAA,EAAA;QAC5BE,EAAI,CAAAD;AACL;MAIA,IAAA,CAAAD,MAAA,GAAA,IAAA;AAED;AACE;AAGF,EAAA,IAAAtB,IAAAA,GAAA;WACM,IAAS,CAAA/B,QAAY,CAAA+B,IAAA;;SAI+CyB,GAAA;QACxE,CAAyDH,MAAA,GAAA,IAAA;AACzD,IAAA,IAAA,CAAArD,QAAS,CAAAwD,OAAA,EAAA;;eAGIC,CAAAC,IAAY,EAAAC,SAAkB,EAAA;IAC7C,OAAC,IAAA,CAAA3D,QAAA,CAAAyD,aAAA,CAAAC,IAAA,EAAAC,SAAA,CAAA;;eAIAC,CAAAC,KAAA,EAAA;AAED,IAAA,OACE,IAAW,CAAA7D,sBAE6B,MACf,CAAA;;AAIzB8D,EAAAA,UAAIA,MAAK,EAAA;eACH,CAAA9D,QAAS,CAAA8D,UAAM,CAAAD,KAAqB,CAAE;;MAK7CE,WAAAA,GAAA;AAEO,IAAA,OAAA,IAAA,CAAY/D,QAAwB,CAAA+D,WAAA;;aAG3CC,CAAAC,MAAA,EAAAC,QAAA,EAAA;IACF,IAAA,CAAAlE,QAAA,CAAAgE,WAAA,CAAAC,MAAA,EAAAC,QAAA,CAAA;AAED;;;AAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvPA,EAAA,OAAAC,wBAAA,CACH,CAAA;;;;;;;;;;;;;"}