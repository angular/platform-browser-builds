/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵwithHttpTransferCache as withHttpTransferCache } from '@angular/common/http';
import { makeEnvironmentProviders, ɵwithDomHydration as withDomHydration } from '@angular/core';
/**
 * Helper function to create an object that represents a Hydration feature.
 */
function hydrationFeature(kind, providers = []) {
    return { ɵkind: kind, ɵproviders: providers };
}
/**
 * Disables DOM nodes reuse during hydration. Effectively makes
 * Angular re-render an application from scratch on the client.
 *
 * When this option is enabled, make sure that the initial navigation
 * option is configured for the Router as `enabledBlocking` by using the
 * `withEnabledBlockingInitialNavigation` in the `provideRouter` call:
 *
 * ```
 * bootstrapApplication(RootComponent, {
 *   providers: [
 *     provideRouter(
 *       // ... other features ...
 *       withEnabledBlockingInitialNavigation()
 *     ),
 *     provideClientHydration(withNoDomReuse())
 *   ]
 * });
 * ```
 *
 * This would ensure that the application is rerendered after all async
 * operations in the Router (such as lazy-loading of components,
 * waiting for async guards and resolvers) are completed to avoid
 * clearing the DOM on the client too soon, thus causing content flicker.
 *
 * @see `provideRouter`
 * @see `withEnabledBlockingInitialNavigation`
 *
 * @publicApi
 * @developerPreview
 */
export function withNoDomReuse() {
    // This feature has no providers and acts as a flag that turns off
    // non-destructive hydration (which otherwise is turned on by default).
    return hydrationFeature(0 /* HydrationFeatureKind.NoDomReuseFeature */);
}
/**
 * Disables HTTP transfer cache. Effectively causes HTTP requests to be performed twice: once on the
 * server and other one on the browser.
 *
 * @publicApi
 * @developerPreview
 */
export function withNoHttpTransferCache() {
    // This feature has no providers and acts as a flag that turns off
    // HTTP transfer cache (which otherwise is turned on by default).
    return hydrationFeature(1 /* HydrationFeatureKind.NoHttpTransferCache */);
}
/**
 * Sets up providers necessary to enable hydration functionality for the application.
 * By default, the function enables the recommended set of features for the optimal
 * performance for most of the applications. You can enable/disable features by
 * passing special functions (from the `HydrationFeatures` set) as arguments to the
 * `provideClientHydration` function.
 *
 * @usageNotes
 *
 * Basic example of how you can enable hydration in your application when
 * `bootstrapApplication` function is used:
 * ```
 * bootstrapApplication(AppComponent, {
 *   providers: [provideClientHydration()]
 * });
 * ```
 *
 * Alternatively if you are using NgModules, you would add `provideClientHydration`
 * to your root app module's provider list.
 * ```
 * @NgModule({
 *   declarations: [RootCmp],
 *   bootstrap: [RootCmp],
 *   providers: [provideClientHydration()],
 * })
 * export class AppModule {}
 * ```
 *
 * @see `withNoDomReuse`
 * @see `withNoHttpTransferCache`
 *
 * @param features Optional features to configure additional router behaviors.
 * @returns A set of providers to enable hydration.
 *
 * @publicApi
 * @developerPreview
 */
export function provideClientHydration(...features) {
    const providers = [];
    const featuresKind = new Set();
    for (const { ɵproviders, ɵkind } of features) {
        featuresKind.add(ɵkind);
        if (ɵproviders.length) {
            providers.push(ɵproviders);
        }
    }
    return makeEnvironmentProviders([
        (featuresKind.has(0 /* HydrationFeatureKind.NoDomReuseFeature */) ? [] : withDomHydration()),
        (featuresKind.has(1 /* HydrationFeatureKind.NoHttpTransferCache */) ? [] : withHttpTransferCache()),
        providers,
    ]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHlkcmF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvcGxhdGZvcm0tYnJvd3Nlci9zcmMvaHlkcmF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBQyxzQkFBc0IsSUFBSSxxQkFBcUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ3JGLE9BQU8sRUFBdUIsd0JBQXdCLEVBQVksaUJBQWlCLElBQUksZ0JBQWdCLEVBQUMsTUFBTSxlQUFlLENBQUM7QUF5QjlIOztHQUVHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FDckIsSUFBaUIsRUFBRSxZQUF3QixFQUFFO0lBQy9DLE9BQU8sRUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUMsQ0FBQztBQUM5QyxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThCRztBQUNILE1BQU0sVUFBVSxjQUFjO0lBQzVCLGtFQUFrRTtJQUNsRSx1RUFBdUU7SUFDdkUsT0FBTyxnQkFBZ0IsZ0RBQXdDLENBQUM7QUFDbEUsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSx1QkFBdUI7SUFFckMsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSxPQUFPLGdCQUFnQixrREFBMEMsQ0FBQztBQUNwRSxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9DRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxHQUFHLFFBQWtEO0lBRTFGLE1BQU0sU0FBUyxHQUFlLEVBQUUsQ0FBQztJQUNqQyxNQUFNLFlBQVksR0FBRyxJQUFJLEdBQUcsRUFBd0IsQ0FBQztJQUVyRCxLQUFLLE1BQU0sRUFBQyxVQUFVLEVBQUUsS0FBSyxFQUFDLElBQUksUUFBUSxFQUFFO1FBQzFDLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFeEIsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFO1lBQ3JCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDNUI7S0FDRjtJQUVELE9BQU8sd0JBQXdCLENBQUM7UUFDOUIsQ0FBQyxZQUFZLENBQUMsR0FBRyxnREFBd0MsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3BGLENBQUMsWUFBWSxDQUFDLEdBQUcsa0RBQTBDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUMzRixTQUFTO0tBQ1YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge8m1d2l0aEh0dHBUcmFuc2ZlckNhY2hlIGFzIHdpdGhIdHRwVHJhbnNmZXJDYWNoZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHtFbnZpcm9ubWVudFByb3ZpZGVycywgbWFrZUVudmlyb25tZW50UHJvdmlkZXJzLCBQcm92aWRlciwgybV3aXRoRG9tSHlkcmF0aW9uIGFzIHdpdGhEb21IeWRyYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIGZlYXR1cmVzIGFzIGFuIGVudW0gdG8gdW5pcXVlbHkgdHlwZSBlYWNoIGBIeWRyYXRpb25GZWF0dXJlYC5cbiAqIEBzZWUgSHlkcmF0aW9uRmVhdHVyZVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEh5ZHJhdGlvbkZlYXR1cmVLaW5kIHtcbiAgTm9Eb21SZXVzZUZlYXR1cmUsXG4gIE5vSHR0cFRyYW5zZmVyQ2FjaGVcbn1cblxuLyoqXG4gKiBIZWxwZXIgdHlwZSB0byByZXByZXNlbnQgYSBIeWRyYXRpb24gZmVhdHVyZS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEh5ZHJhdGlvbkZlYXR1cmU8RmVhdHVyZUtpbmQgZXh0ZW5kcyBIeWRyYXRpb25GZWF0dXJlS2luZD4ge1xuICDJtWtpbmQ6IEZlYXR1cmVLaW5kO1xuICDJtXByb3ZpZGVyczogUHJvdmlkZXJbXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBIeWRyYXRpb24gZmVhdHVyZS5cbiAqL1xuZnVuY3Rpb24gaHlkcmF0aW9uRmVhdHVyZTxGZWF0dXJlS2luZCBleHRlbmRzIEh5ZHJhdGlvbkZlYXR1cmVLaW5kPihcbiAgICBraW5kOiBGZWF0dXJlS2luZCwgcHJvdmlkZXJzOiBQcm92aWRlcltdID0gW10pOiBIeWRyYXRpb25GZWF0dXJlPEZlYXR1cmVLaW5kPiB7XG4gIHJldHVybiB7ybVraW5kOiBraW5kLCDJtXByb3ZpZGVyczogcHJvdmlkZXJzfTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBET00gbm9kZXMgcmV1c2UgZHVyaW5nIGh5ZHJhdGlvbi4gRWZmZWN0aXZlbHkgbWFrZXNcbiAqIEFuZ3VsYXIgcmUtcmVuZGVyIGFuIGFwcGxpY2F0aW9uIGZyb20gc2NyYXRjaCBvbiB0aGUgY2xpZW50LlxuICpcbiAqIFdoZW4gdGhpcyBvcHRpb24gaXMgZW5hYmxlZCwgbWFrZSBzdXJlIHRoYXQgdGhlIGluaXRpYWwgbmF2aWdhdGlvblxuICogb3B0aW9uIGlzIGNvbmZpZ3VyZWQgZm9yIHRoZSBSb3V0ZXIgYXMgYGVuYWJsZWRCbG9ja2luZ2AgYnkgdXNpbmcgdGhlXG4gKiBgd2l0aEVuYWJsZWRCbG9ja2luZ0luaXRpYWxOYXZpZ2F0aW9uYCBpbiB0aGUgYHByb3ZpZGVSb3V0ZXJgIGNhbGw6XG4gKlxuICogYGBgXG4gKiBib290c3RyYXBBcHBsaWNhdGlvbihSb290Q29tcG9uZW50LCB7XG4gKiAgIHByb3ZpZGVyczogW1xuICogICAgIHByb3ZpZGVSb3V0ZXIoXG4gKiAgICAgICAvLyAuLi4gb3RoZXIgZmVhdHVyZXMgLi4uXG4gKiAgICAgICB3aXRoRW5hYmxlZEJsb2NraW5nSW5pdGlhbE5hdmlnYXRpb24oKVxuICogICAgICksXG4gKiAgICAgcHJvdmlkZUNsaWVudEh5ZHJhdGlvbih3aXRoTm9Eb21SZXVzZSgpKVxuICogICBdXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFRoaXMgd291bGQgZW5zdXJlIHRoYXQgdGhlIGFwcGxpY2F0aW9uIGlzIHJlcmVuZGVyZWQgYWZ0ZXIgYWxsIGFzeW5jXG4gKiBvcGVyYXRpb25zIGluIHRoZSBSb3V0ZXIgKHN1Y2ggYXMgbGF6eS1sb2FkaW5nIG9mIGNvbXBvbmVudHMsXG4gKiB3YWl0aW5nIGZvciBhc3luYyBndWFyZHMgYW5kIHJlc29sdmVycykgYXJlIGNvbXBsZXRlZCB0byBhdm9pZFxuICogY2xlYXJpbmcgdGhlIERPTSBvbiB0aGUgY2xpZW50IHRvbyBzb29uLCB0aHVzIGNhdXNpbmcgY29udGVudCBmbGlja2VyLlxuICpcbiAqIEBzZWUgYHByb3ZpZGVSb3V0ZXJgXG4gKiBAc2VlIGB3aXRoRW5hYmxlZEJsb2NraW5nSW5pdGlhbE5hdmlnYXRpb25gXG4gKlxuICogQHB1YmxpY0FwaVxuICogQGRldmVsb3BlclByZXZpZXdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhOb0RvbVJldXNlKCk6IEh5ZHJhdGlvbkZlYXR1cmU8SHlkcmF0aW9uRmVhdHVyZUtpbmQuTm9Eb21SZXVzZUZlYXR1cmU+IHtcbiAgLy8gVGhpcyBmZWF0dXJlIGhhcyBubyBwcm92aWRlcnMgYW5kIGFjdHMgYXMgYSBmbGFnIHRoYXQgdHVybnMgb2ZmXG4gIC8vIG5vbi1kZXN0cnVjdGl2ZSBoeWRyYXRpb24gKHdoaWNoIG90aGVyd2lzZSBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdCkuXG4gIHJldHVybiBoeWRyYXRpb25GZWF0dXJlKEh5ZHJhdGlvbkZlYXR1cmVLaW5kLk5vRG9tUmV1c2VGZWF0dXJlKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBIVFRQIHRyYW5zZmVyIGNhY2hlLiBFZmZlY3RpdmVseSBjYXVzZXMgSFRUUCByZXF1ZXN0cyB0byBiZSBwZXJmb3JtZWQgdHdpY2U6IG9uY2Ugb24gdGhlXG4gKiBzZXJ2ZXIgYW5kIG90aGVyIG9uZSBvbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcHVibGljQXBpXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aE5vSHR0cFRyYW5zZmVyQ2FjaGUoKTpcbiAgICBIeWRyYXRpb25GZWF0dXJlPEh5ZHJhdGlvbkZlYXR1cmVLaW5kLk5vSHR0cFRyYW5zZmVyQ2FjaGU+IHtcbiAgLy8gVGhpcyBmZWF0dXJlIGhhcyBubyBwcm92aWRlcnMgYW5kIGFjdHMgYXMgYSBmbGFnIHRoYXQgdHVybnMgb2ZmXG4gIC8vIEhUVFAgdHJhbnNmZXIgY2FjaGUgKHdoaWNoIG90aGVyd2lzZSBpcyB0dXJuZWQgb24gYnkgZGVmYXVsdCkuXG4gIHJldHVybiBoeWRyYXRpb25GZWF0dXJlKEh5ZHJhdGlvbkZlYXR1cmVLaW5kLk5vSHR0cFRyYW5zZmVyQ2FjaGUpO1xufVxuXG4vKipcbiAqIFNldHMgdXAgcHJvdmlkZXJzIG5lY2Vzc2FyeSB0byBlbmFibGUgaHlkcmF0aW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqIEJ5IGRlZmF1bHQsIHRoZSBmdW5jdGlvbiBlbmFibGVzIHRoZSByZWNvbW1lbmRlZCBzZXQgb2YgZmVhdHVyZXMgZm9yIHRoZSBvcHRpbWFsXG4gKiBwZXJmb3JtYW5jZSBmb3IgbW9zdCBvZiB0aGUgYXBwbGljYXRpb25zLiBZb3UgY2FuIGVuYWJsZS9kaXNhYmxlIGZlYXR1cmVzIGJ5XG4gKiBwYXNzaW5nIHNwZWNpYWwgZnVuY3Rpb25zIChmcm9tIHRoZSBgSHlkcmF0aW9uRmVhdHVyZXNgIHNldCkgYXMgYXJndW1lbnRzIHRvIHRoZVxuICogYHByb3ZpZGVDbGllbnRIeWRyYXRpb25gIGZ1bmN0aW9uLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogQmFzaWMgZXhhbXBsZSBvZiBob3cgeW91IGNhbiBlbmFibGUgaHlkcmF0aW9uIGluIHlvdXIgYXBwbGljYXRpb24gd2hlblxuICogYGJvb3RzdHJhcEFwcGxpY2F0aW9uYCBmdW5jdGlvbiBpcyB1c2VkOlxuICogYGBgXG4gKiBib290c3RyYXBBcHBsaWNhdGlvbihBcHBDb21wb25lbnQsIHtcbiAqICAgcHJvdmlkZXJzOiBbcHJvdmlkZUNsaWVudEh5ZHJhdGlvbigpXVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5IGlmIHlvdSBhcmUgdXNpbmcgTmdNb2R1bGVzLCB5b3Ugd291bGQgYWRkIGBwcm92aWRlQ2xpZW50SHlkcmF0aW9uYFxuICogdG8geW91ciByb290IGFwcCBtb2R1bGUncyBwcm92aWRlciBsaXN0LlxuICogYGBgXG4gKiBATmdNb2R1bGUoe1xuICogICBkZWNsYXJhdGlvbnM6IFtSb290Q21wXSxcbiAqICAgYm9vdHN0cmFwOiBbUm9vdENtcF0sXG4gKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVDbGllbnRIeWRyYXRpb24oKV0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7fVxuICogYGBgXG4gKlxuICogQHNlZSBgd2l0aE5vRG9tUmV1c2VgXG4gKiBAc2VlIGB3aXRoTm9IdHRwVHJhbnNmZXJDYWNoZWBcbiAqXG4gKiBAcGFyYW0gZmVhdHVyZXMgT3B0aW9uYWwgZmVhdHVyZXMgdG8gY29uZmlndXJlIGFkZGl0aW9uYWwgcm91dGVyIGJlaGF2aW9ycy5cbiAqIEByZXR1cm5zIEEgc2V0IG9mIHByb3ZpZGVycyB0byBlbmFibGUgaHlkcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm92aWRlQ2xpZW50SHlkcmF0aW9uKC4uLmZlYXR1cmVzOiBIeWRyYXRpb25GZWF0dXJlPEh5ZHJhdGlvbkZlYXR1cmVLaW5kPltdKTpcbiAgICBFbnZpcm9ubWVudFByb3ZpZGVycyB7XG4gIGNvbnN0IHByb3ZpZGVyczogUHJvdmlkZXJbXSA9IFtdO1xuICBjb25zdCBmZWF0dXJlc0tpbmQgPSBuZXcgU2V0PEh5ZHJhdGlvbkZlYXR1cmVLaW5kPigpO1xuXG4gIGZvciAoY29uc3Qge8m1cHJvdmlkZXJzLCDJtWtpbmR9IG9mIGZlYXR1cmVzKSB7XG4gICAgZmVhdHVyZXNLaW5kLmFkZCjJtWtpbmQpO1xuXG4gICAgaWYgKMm1cHJvdmlkZXJzLmxlbmd0aCkge1xuICAgICAgcHJvdmlkZXJzLnB1c2goybVwcm92aWRlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWtlRW52aXJvbm1lbnRQcm92aWRlcnMoW1xuICAgIChmZWF0dXJlc0tpbmQuaGFzKEh5ZHJhdGlvbkZlYXR1cmVLaW5kLk5vRG9tUmV1c2VGZWF0dXJlKSA/IFtdIDogd2l0aERvbUh5ZHJhdGlvbigpKSxcbiAgICAoZmVhdHVyZXNLaW5kLmhhcyhIeWRyYXRpb25GZWF0dXJlS2luZC5Ob0h0dHBUcmFuc2ZlckNhY2hlKSA/IFtdIDogd2l0aEh0dHBUcmFuc2ZlckNhY2hlKCkpLFxuICAgIHByb3ZpZGVycyxcbiAgXSk7XG59XG4iXX0=