/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ɵwithHttpTransferCache } from '@angular/common/http';
import { ENVIRONMENT_INITIALIZER, inject, makeEnvironmentProviders, NgZone, ɵConsole as Console, ɵformatRuntimeError as formatRuntimeError, ɵwithDomHydration as withDomHydration, ɵwithEventReplay, ɵwithI18nSupport } from '@angular/core';
/**
 * The list of features as an enum to uniquely type each `HydrationFeature`.
 * @see {@link HydrationFeature}
 *
 * @publicApi
 */
export var HydrationFeatureKind;
(function (HydrationFeatureKind) {
    HydrationFeatureKind[HydrationFeatureKind["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
    HydrationFeatureKind[HydrationFeatureKind["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
    HydrationFeatureKind[HydrationFeatureKind["I18nSupport"] = 2] = "I18nSupport";
    HydrationFeatureKind[HydrationFeatureKind["EventReplay"] = 3] = "EventReplay";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));
/**
 * Helper function to create an object that represents a Hydration feature.
 */
function hydrationFeature(ɵkind, ɵproviders = [], ɵoptions = {}) {
    return { ɵkind, ɵproviders };
}
/**
 * Disables HTTP transfer cache. Effectively causes HTTP requests to be performed twice: once on the
 * server and other one on the browser.
 *
 * @publicApi
 */
export function withNoHttpTransferCache() {
    // This feature has no providers and acts as a flag that turns off
    // HTTP transfer cache (which otherwise is turned on by default).
    return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);
}
/**
 * The function accepts a an object, which allows to configure cache parameters,
 * such as which headers should be included (no headers are included by default),
 * wether POST requests should be cached or a callback function to determine if a
 * particular request should be cached.
 *
 * @publicApi
 */
export function withHttpTransferCacheOptions(options) {
    // This feature has no providers and acts as a flag to pass options to the HTTP transfer cache.
    return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, ɵwithHttpTransferCache(options));
}
/**
 * Enables support for hydrating i18n blocks.
 *
 * @developerPreview
 * @publicApi
 */
export function withI18nSupport() {
    return hydrationFeature(HydrationFeatureKind.I18nSupport, ɵwithI18nSupport());
}
/**
 * Enables support for event replay
 *
 * @developerPreview
 * @publicApi
 */
export function withEventReplay() {
    return hydrationFeature(HydrationFeatureKind.EventReplay, ɵwithEventReplay());
}
/**
 * Returns an `ENVIRONMENT_INITIALIZER` token setup with a function
 * that verifies whether compatible ZoneJS was used in an application
 * and logs a warning in a console if it's not the case.
 */
function provideZoneJsCompatibilityDetector() {
    return [{
            provide: ENVIRONMENT_INITIALIZER,
            useValue: () => {
                const ngZone = inject(NgZone);
                // Checking `ngZone instanceof NgZone` would be insufficient here,
                // because custom implementations might use NgZone as a base class.
                if (ngZone.constructor !== NgZone) {
                    const console = inject(Console);
                    const message = formatRuntimeError(-5000 /* RuntimeErrorCode.UNSUPPORTED_ZONEJS_INSTANCE */, 'Angular detected that hydration was enabled for an application ' +
                        'that uses a custom or a noop Zone.js implementation. ' +
                        'This is not yet a fully supported configuration.');
                    // tslint:disable-next-line:no-console
                    console.warn(message);
                }
            },
            multi: true,
        }];
}
/**
 * Sets up providers necessary to enable hydration functionality for the application.
 *
 * By default, the function enables the recommended set of features for the optimal
 * performance for most of the applications. It includes the following features:
 *
 * * Reconciling DOM hydration. Learn more about it [here](guide/hydration).
 * * [`HttpClient`](api/common/http/HttpClient) response caching while running on the server and
 * transferring this cache to the client to avoid extra HTTP requests. Learn more about data caching
 * [here](guide/ssr#caching-data-when-using-httpclient).
 *
 * These functions allow you to disable some of the default features or configure features
 * * {@link withNoHttpTransferCache} to disable HTTP transfer cache
 * * {@link withHttpTransferCacheOptions} to configure some HTTP transfer cache options
 *
 * @usageNotes
 *
 * Basic example of how you can enable hydration in your application when
 * `bootstrapApplication` function is used:
 * ```
 * bootstrapApplication(AppComponent, {
 *   providers: [provideClientHydration()]
 * });
 * ```
 *
 * Alternatively if you are using NgModules, you would add `provideClientHydration`
 * to your root app module's provider list.
 * ```
 * @NgModule({
 *   declarations: [RootCmp],
 *   bootstrap: [RootCmp],
 *   providers: [provideClientHydration()],
 * })
 * export class AppModule {}
 * ```
 *
 * @see {@link withNoHttpTransferCache}
 * @see {@link withHttpTransferCacheOptions}
 *
 * @param features Optional features to configure additional router behaviors.
 * @returns A set of providers to enable hydration.
 *
 * @publicApi
 */
export function provideClientHydration(...features) {
    const providers = [];
    const featuresKind = new Set();
    const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);
    for (const { ɵproviders, ɵkind } of features) {
        featuresKind.add(ɵkind);
        if (ɵproviders.length) {
            providers.push(ɵproviders);
        }
    }
    if (typeof ngDevMode !== 'undefined' && ngDevMode &&
        featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) && hasHttpTransferCacheOptions) {
        // TODO: Make this a runtime error
        throw new Error('Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.');
    }
    return makeEnvironmentProviders([
        (typeof ngDevMode !== 'undefined' && ngDevMode) ? provideZoneJsCompatibilityDetector() : [],
        withDomHydration(),
        ((featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions) ?
            [] :
            ɵwithHttpTransferCache({})),
        providers,
    ]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHlkcmF0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvcGxhdGZvcm0tYnJvd3Nlci9zcmMvaHlkcmF0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBMkIsc0JBQXNCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUN0RixPQUFPLEVBQUMsdUJBQXVCLEVBQXdCLE1BQU0sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLEVBQVksUUFBUSxJQUFJLE9BQU8sRUFBRSxtQkFBbUIsSUFBSSxrQkFBa0IsRUFBRSxpQkFBaUIsSUFBSSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUkzUTs7Ozs7R0FLRztBQUNILE1BQU0sQ0FBTixJQUFZLG9CQUtYO0FBTEQsV0FBWSxvQkFBb0I7SUFDOUIsNkZBQW1CLENBQUE7SUFDbkIsdUdBQXdCLENBQUE7SUFDeEIsNkVBQVcsQ0FBQTtJQUNYLDZFQUFXLENBQUE7QUFDYixDQUFDLEVBTFcsb0JBQW9CLEtBQXBCLG9CQUFvQixRQUsvQjtBQVlEOztHQUVHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FDckIsS0FBa0IsRUFBRSxhQUF5QixFQUFFLEVBQy9DLFdBQW9CLEVBQUU7SUFDeEIsT0FBTyxFQUFDLEtBQUssRUFBRSxVQUFVLEVBQUMsQ0FBQztBQUM3QixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsdUJBQXVCO0lBRXJDLGtFQUFrRTtJQUNsRSxpRUFBaUU7SUFDakUsT0FBTyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLDRCQUE0QixDQUN4QyxPQUFpQztJQUVuQywrRkFBK0Y7SUFDL0YsT0FBTyxnQkFBZ0IsQ0FDbkIsb0JBQW9CLENBQUMsd0JBQXdCLEVBQUUsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUN0RixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsZUFBZTtJQUM3QixPQUFPLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7QUFDaEYsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGVBQWU7SUFDN0IsT0FBTyxnQkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0FBQ2hGLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxrQ0FBa0M7SUFDekMsT0FBTyxDQUFDO1lBQ04sT0FBTyxFQUFFLHVCQUF1QjtZQUNoQyxRQUFRLEVBQUUsR0FBRyxFQUFFO2dCQUNiLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDOUIsa0VBQWtFO2dCQUNsRSxtRUFBbUU7Z0JBQ25FLElBQUksTUFBTSxDQUFDLFdBQVcsS0FBSyxNQUFNLEVBQUUsQ0FBQztvQkFDbEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO29CQUNoQyxNQUFNLE9BQU8sR0FBRyxrQkFBa0IsMkRBRTlCLGlFQUFpRTt3QkFDN0QsdURBQXVEO3dCQUN2RCxrREFBa0QsQ0FBQyxDQUFDO29CQUM1RCxzQ0FBc0M7b0JBQ3RDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3hCLENBQUM7WUFDSCxDQUFDO1lBQ0QsS0FBSyxFQUFFLElBQUk7U0FDWixDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EyQ0c7QUFDSCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsR0FBRyxRQUFrRDtJQUUxRixNQUFNLFNBQVMsR0FBZSxFQUFFLENBQUM7SUFDakMsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQXdCLENBQUM7SUFDckQsTUFBTSwyQkFBMkIsR0FDN0IsWUFBWSxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBRXBFLEtBQUssTUFBTSxFQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUMsSUFBSSxRQUFRLEVBQUUsQ0FBQztRQUMzQyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXhCLElBQUksVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3RCLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0IsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFJLE9BQU8sU0FBUyxLQUFLLFdBQVcsSUFBSSxTQUFTO1FBQzdDLFlBQVksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsbUJBQW1CLENBQUMsSUFBSSwyQkFBMkIsRUFBRSxDQUFDO1FBQzlGLGtDQUFrQztRQUNsQyxNQUFNLElBQUksS0FBSyxDQUNYLHNLQUFzSyxDQUFDLENBQUM7SUFDOUssQ0FBQztJQUVELE9BQU8sd0JBQXdCLENBQUM7UUFDOUIsQ0FBQyxPQUFPLFNBQVMsS0FBSyxXQUFXLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLGtDQUFrQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDM0YsZ0JBQWdCLEVBQUU7UUFDbEIsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsbUJBQW1CLENBQUMsSUFBSSwyQkFBMkIsQ0FBQyxDQUFDLENBQUM7WUFDekYsRUFBRSxDQUFDLENBQUM7WUFDSixzQkFBc0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNoQyxTQUFTO0tBQ1YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge0h0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucywgybV3aXRoSHR0cFRyYW5zZmVyQ2FjaGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7RU5WSVJPTk1FTlRfSU5JVElBTElaRVIsIEVudmlyb25tZW50UHJvdmlkZXJzLCBpbmplY3QsIG1ha2VFbnZpcm9ubWVudFByb3ZpZGVycywgTmdab25lLCBQcm92aWRlciwgybVDb25zb2xlIGFzIENvbnNvbGUsIMm1Zm9ybWF0UnVudGltZUVycm9yIGFzIGZvcm1hdFJ1bnRpbWVFcnJvciwgybV3aXRoRG9tSHlkcmF0aW9uIGFzIHdpdGhEb21IeWRyYXRpb24sIMm1d2l0aEV2ZW50UmVwbGF5LCDJtXdpdGhJMThuU3VwcG9ydH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7UnVudGltZUVycm9yQ29kZX0gZnJvbSAnLi9lcnJvcnMnO1xuXG4vKipcbiAqIFRoZSBsaXN0IG9mIGZlYXR1cmVzIGFzIGFuIGVudW0gdG8gdW5pcXVlbHkgdHlwZSBlYWNoIGBIeWRyYXRpb25GZWF0dXJlYC5cbiAqIEBzZWUge0BsaW5rIEh5ZHJhdGlvbkZlYXR1cmV9XG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgZW51bSBIeWRyYXRpb25GZWF0dXJlS2luZCB7XG4gIE5vSHR0cFRyYW5zZmVyQ2FjaGUsXG4gIEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyxcbiAgSTE4blN1cHBvcnQsXG4gIEV2ZW50UmVwbGF5LFxufVxuXG4vKipcbiAqIEhlbHBlciB0eXBlIHRvIHJlcHJlc2VudCBhIEh5ZHJhdGlvbiBmZWF0dXJlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIeWRyYXRpb25GZWF0dXJlPEZlYXR1cmVLaW5kIGV4dGVuZHMgSHlkcmF0aW9uRmVhdHVyZUtpbmQ+IHtcbiAgybVraW5kOiBGZWF0dXJlS2luZDtcbiAgybVwcm92aWRlcnM6IFByb3ZpZGVyW107XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgSHlkcmF0aW9uIGZlYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIGh5ZHJhdGlvbkZlYXR1cmU8RmVhdHVyZUtpbmQgZXh0ZW5kcyBIeWRyYXRpb25GZWF0dXJlS2luZD4oXG4gICAgybVraW5kOiBGZWF0dXJlS2luZCwgybVwcm92aWRlcnM6IFByb3ZpZGVyW10gPSBbXSxcbiAgICDJtW9wdGlvbnM6IHVua25vd24gPSB7fSk6IEh5ZHJhdGlvbkZlYXR1cmU8RmVhdHVyZUtpbmQ+IHtcbiAgcmV0dXJuIHvJtWtpbmQsIMm1cHJvdmlkZXJzfTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBIVFRQIHRyYW5zZmVyIGNhY2hlLiBFZmZlY3RpdmVseSBjYXVzZXMgSFRUUCByZXF1ZXN0cyB0byBiZSBwZXJmb3JtZWQgdHdpY2U6IG9uY2Ugb24gdGhlXG4gKiBzZXJ2ZXIgYW5kIG90aGVyIG9uZSBvbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoTm9IdHRwVHJhbnNmZXJDYWNoZSgpOlxuICAgIEh5ZHJhdGlvbkZlYXR1cmU8SHlkcmF0aW9uRmVhdHVyZUtpbmQuTm9IdHRwVHJhbnNmZXJDYWNoZT4ge1xuICAvLyBUaGlzIGZlYXR1cmUgaGFzIG5vIHByb3ZpZGVycyBhbmQgYWN0cyBhcyBhIGZsYWcgdGhhdCB0dXJucyBvZmZcbiAgLy8gSFRUUCB0cmFuc2ZlciBjYWNoZSAod2hpY2ggb3RoZXJ3aXNlIGlzIHR1cm5lZCBvbiBieSBkZWZhdWx0KS5cbiAgcmV0dXJuIGh5ZHJhdGlvbkZlYXR1cmUoSHlkcmF0aW9uRmVhdHVyZUtpbmQuTm9IdHRwVHJhbnNmZXJDYWNoZSk7XG59XG5cbi8qKlxuICogVGhlIGZ1bmN0aW9uIGFjY2VwdHMgYSBhbiBvYmplY3QsIHdoaWNoIGFsbG93cyB0byBjb25maWd1cmUgY2FjaGUgcGFyYW1ldGVycyxcbiAqIHN1Y2ggYXMgd2hpY2ggaGVhZGVycyBzaG91bGQgYmUgaW5jbHVkZWQgKG5vIGhlYWRlcnMgYXJlIGluY2x1ZGVkIGJ5IGRlZmF1bHQpLFxuICogd2V0aGVyIFBPU1QgcmVxdWVzdHMgc2hvdWxkIGJlIGNhY2hlZCBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhXG4gKiBwYXJ0aWN1bGFyIHJlcXVlc3Qgc2hvdWxkIGJlIGNhY2hlZC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zKFxuICAgIG9wdGlvbnM6IEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyxcbiAgICApOiBIeWRyYXRpb25GZWF0dXJlPEh5ZHJhdGlvbkZlYXR1cmVLaW5kLkh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucz4ge1xuICAvLyBUaGlzIGZlYXR1cmUgaGFzIG5vIHByb3ZpZGVycyBhbmQgYWN0cyBhcyBhIGZsYWcgdG8gcGFzcyBvcHRpb25zIHRvIHRoZSBIVFRQIHRyYW5zZmVyIGNhY2hlLlxuICByZXR1cm4gaHlkcmF0aW9uRmVhdHVyZShcbiAgICAgIEh5ZHJhdGlvbkZlYXR1cmVLaW5kLkh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucywgybV3aXRoSHR0cFRyYW5zZmVyQ2FjaGUob3B0aW9ucykpO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgc3VwcG9ydCBmb3IgaHlkcmF0aW5nIGkxOG4gYmxvY2tzLlxuICpcbiAqIEBkZXZlbG9wZXJQcmV2aWV3XG4gKiBAcHVibGljQXBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoSTE4blN1cHBvcnQoKTogSHlkcmF0aW9uRmVhdHVyZTxIeWRyYXRpb25GZWF0dXJlS2luZC5JMThuU3VwcG9ydD4ge1xuICByZXR1cm4gaHlkcmF0aW9uRmVhdHVyZShIeWRyYXRpb25GZWF0dXJlS2luZC5JMThuU3VwcG9ydCwgybV3aXRoSTE4blN1cHBvcnQoKSk7XG59XG5cbi8qKlxuICogRW5hYmxlcyBzdXBwb3J0IGZvciBldmVudCByZXBsYXlcbiAqXG4gKiBAZGV2ZWxvcGVyUHJldmlld1xuICogQHB1YmxpY0FwaVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aEV2ZW50UmVwbGF5KCk6IEh5ZHJhdGlvbkZlYXR1cmU8SHlkcmF0aW9uRmVhdHVyZUtpbmQuRXZlbnRSZXBsYXk+IHtcbiAgcmV0dXJuIGh5ZHJhdGlvbkZlYXR1cmUoSHlkcmF0aW9uRmVhdHVyZUtpbmQuRXZlbnRSZXBsYXksIMm1d2l0aEV2ZW50UmVwbGF5KCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYEVOVklST05NRU5UX0lOSVRJQUxJWkVSYCB0b2tlbiBzZXR1cCB3aXRoIGEgZnVuY3Rpb25cbiAqIHRoYXQgdmVyaWZpZXMgd2hldGhlciBjb21wYXRpYmxlIFpvbmVKUyB3YXMgdXNlZCBpbiBhbiBhcHBsaWNhdGlvblxuICogYW5kIGxvZ3MgYSB3YXJuaW5nIGluIGEgY29uc29sZSBpZiBpdCdzIG5vdCB0aGUgY2FzZS5cbiAqL1xuZnVuY3Rpb24gcHJvdmlkZVpvbmVKc0NvbXBhdGliaWxpdHlEZXRlY3RvcigpOiBQcm92aWRlcltdIHtcbiAgcmV0dXJuIFt7XG4gICAgcHJvdmlkZTogRU5WSVJPTk1FTlRfSU5JVElBTElaRVIsXG4gICAgdXNlVmFsdWU6ICgpID0+IHtcbiAgICAgIGNvbnN0IG5nWm9uZSA9IGluamVjdChOZ1pvbmUpO1xuICAgICAgLy8gQ2hlY2tpbmcgYG5nWm9uZSBpbnN0YW5jZW9mIE5nWm9uZWAgd291bGQgYmUgaW5zdWZmaWNpZW50IGhlcmUsXG4gICAgICAvLyBiZWNhdXNlIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgbWlnaHQgdXNlIE5nWm9uZSBhcyBhIGJhc2UgY2xhc3MuXG4gICAgICBpZiAobmdab25lLmNvbnN0cnVjdG9yICE9PSBOZ1pvbmUpIHtcbiAgICAgICAgY29uc3QgY29uc29sZSA9IGluamVjdChDb25zb2xlKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGZvcm1hdFJ1bnRpbWVFcnJvcihcbiAgICAgICAgICAgIFJ1bnRpbWVFcnJvckNvZGUuVU5TVVBQT1JURURfWk9ORUpTX0lOU1RBTkNFLFxuICAgICAgICAgICAgJ0FuZ3VsYXIgZGV0ZWN0ZWQgdGhhdCBoeWRyYXRpb24gd2FzIGVuYWJsZWQgZm9yIGFuIGFwcGxpY2F0aW9uICcgK1xuICAgICAgICAgICAgICAgICd0aGF0IHVzZXMgYSBjdXN0b20gb3IgYSBub29wIFpvbmUuanMgaW1wbGVtZW50YXRpb24uICcgK1xuICAgICAgICAgICAgICAgICdUaGlzIGlzIG5vdCB5ZXQgYSBmdWxseSBzdXBwb3J0ZWQgY29uZmlndXJhdGlvbi4nKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbXVsdGk6IHRydWUsXG4gIH1dO1xufVxuXG4vKipcbiAqIFNldHMgdXAgcHJvdmlkZXJzIG5lY2Vzc2FyeSB0byBlbmFibGUgaHlkcmF0aW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgZnVuY3Rpb24gZW5hYmxlcyB0aGUgcmVjb21tZW5kZWQgc2V0IG9mIGZlYXR1cmVzIGZvciB0aGUgb3B0aW1hbFxuICogcGVyZm9ybWFuY2UgZm9yIG1vc3Qgb2YgdGhlIGFwcGxpY2F0aW9ucy4gSXQgaW5jbHVkZXMgdGhlIGZvbGxvd2luZyBmZWF0dXJlczpcbiAqXG4gKiAqIFJlY29uY2lsaW5nIERPTSBoeWRyYXRpb24uIExlYXJuIG1vcmUgYWJvdXQgaXQgW2hlcmVdKGd1aWRlL2h5ZHJhdGlvbikuXG4gKiAqIFtgSHR0cENsaWVudGBdKGFwaS9jb21tb24vaHR0cC9IdHRwQ2xpZW50KSByZXNwb25zZSBjYWNoaW5nIHdoaWxlIHJ1bm5pbmcgb24gdGhlIHNlcnZlciBhbmRcbiAqIHRyYW5zZmVycmluZyB0aGlzIGNhY2hlIHRvIHRoZSBjbGllbnQgdG8gYXZvaWQgZXh0cmEgSFRUUCByZXF1ZXN0cy4gTGVhcm4gbW9yZSBhYm91dCBkYXRhIGNhY2hpbmdcbiAqIFtoZXJlXShndWlkZS9zc3IjY2FjaGluZy1kYXRhLXdoZW4tdXNpbmctaHR0cGNsaWVudCkuXG4gKlxuICogVGhlc2UgZnVuY3Rpb25zIGFsbG93IHlvdSB0byBkaXNhYmxlIHNvbWUgb2YgdGhlIGRlZmF1bHQgZmVhdHVyZXMgb3IgY29uZmlndXJlIGZlYXR1cmVzXG4gKiAqIHtAbGluayB3aXRoTm9IdHRwVHJhbnNmZXJDYWNoZX0gdG8gZGlzYWJsZSBIVFRQIHRyYW5zZmVyIGNhY2hlXG4gKiAqIHtAbGluayB3aXRoSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zfSB0byBjb25maWd1cmUgc29tZSBIVFRQIHRyYW5zZmVyIGNhY2hlIG9wdGlvbnNcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIEJhc2ljIGV4YW1wbGUgb2YgaG93IHlvdSBjYW4gZW5hYmxlIGh5ZHJhdGlvbiBpbiB5b3VyIGFwcGxpY2F0aW9uIHdoZW5cbiAqIGBib290c3RyYXBBcHBsaWNhdGlvbmAgZnVuY3Rpb24gaXMgdXNlZDpcbiAqIGBgYFxuICogYm9vdHN0cmFwQXBwbGljYXRpb24oQXBwQ29tcG9uZW50LCB7XG4gKiAgIHByb3ZpZGVyczogW3Byb3ZpZGVDbGllbnRIeWRyYXRpb24oKV1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQWx0ZXJuYXRpdmVseSBpZiB5b3UgYXJlIHVzaW5nIE5nTW9kdWxlcywgeW91IHdvdWxkIGFkZCBgcHJvdmlkZUNsaWVudEh5ZHJhdGlvbmBcbiAqIHRvIHlvdXIgcm9vdCBhcHAgbW9kdWxlJ3MgcHJvdmlkZXIgbGlzdC5cbiAqIGBgYFxuICogQE5nTW9kdWxlKHtcbiAqICAgZGVjbGFyYXRpb25zOiBbUm9vdENtcF0sXG4gKiAgIGJvb3RzdHJhcDogW1Jvb3RDbXBdLFxuICogICBwcm92aWRlcnM6IFtwcm92aWRlQ2xpZW50SHlkcmF0aW9uKCldLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge31cbiAqIGBgYFxuICpcbiAqIEBzZWUge0BsaW5rIHdpdGhOb0h0dHBUcmFuc2ZlckNhY2hlfVxuICogQHNlZSB7QGxpbmsgd2l0aEh0dHBUcmFuc2ZlckNhY2hlT3B0aW9uc31cbiAqXG4gKiBAcGFyYW0gZmVhdHVyZXMgT3B0aW9uYWwgZmVhdHVyZXMgdG8gY29uZmlndXJlIGFkZGl0aW9uYWwgcm91dGVyIGJlaGF2aW9ycy5cbiAqIEByZXR1cm5zIEEgc2V0IG9mIHByb3ZpZGVycyB0byBlbmFibGUgaHlkcmF0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVDbGllbnRIeWRyYXRpb24oLi4uZmVhdHVyZXM6IEh5ZHJhdGlvbkZlYXR1cmU8SHlkcmF0aW9uRmVhdHVyZUtpbmQ+W10pOlxuICAgIEVudmlyb25tZW50UHJvdmlkZXJzIHtcbiAgY29uc3QgcHJvdmlkZXJzOiBQcm92aWRlcltdID0gW107XG4gIGNvbnN0IGZlYXR1cmVzS2luZCA9IG5ldyBTZXQ8SHlkcmF0aW9uRmVhdHVyZUtpbmQ+KCk7XG4gIGNvbnN0IGhhc0h0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyA9XG4gICAgICBmZWF0dXJlc0tpbmQuaGFzKEh5ZHJhdGlvbkZlYXR1cmVLaW5kLkh0dHBUcmFuc2ZlckNhY2hlT3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCB7ybVwcm92aWRlcnMsIMm1a2luZH0gb2YgZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlc0tpbmQuYWRkKMm1a2luZCk7XG5cbiAgICBpZiAoybVwcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICBwcm92aWRlcnMucHVzaCjJtXByb3ZpZGVycyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgIT09ICd1bmRlZmluZWQnICYmIG5nRGV2TW9kZSAmJlxuICAgICAgZmVhdHVyZXNLaW5kLmhhcyhIeWRyYXRpb25GZWF0dXJlS2luZC5Ob0h0dHBUcmFuc2ZlckNhY2hlKSAmJiBoYXNIdHRwVHJhbnNmZXJDYWNoZU9wdGlvbnMpIHtcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgYSBydW50aW1lIGVycm9yXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ29uZmlndXJhdGlvbiBlcnJvcjogZm91bmQgYm90aCB3aXRoSHR0cFRyYW5zZmVyQ2FjaGVPcHRpb25zKCkgYW5kIHdpdGhOb0h0dHBUcmFuc2ZlckNhY2hlKCkgaW4gdGhlIHNhbWUgY2FsbCB0byBwcm92aWRlQ2xpZW50SHlkcmF0aW9uKCksIHdoaWNoIGlzIGEgY29udHJhZGljdGlvbi4nKTtcbiAgfVxuXG4gIHJldHVybiBtYWtlRW52aXJvbm1lbnRQcm92aWRlcnMoW1xuICAgICh0eXBlb2YgbmdEZXZNb2RlICE9PSAndW5kZWZpbmVkJyAmJiBuZ0Rldk1vZGUpID8gcHJvdmlkZVpvbmVKc0NvbXBhdGliaWxpdHlEZXRlY3RvcigpIDogW10sXG4gICAgd2l0aERvbUh5ZHJhdGlvbigpLFxuICAgICgoZmVhdHVyZXNLaW5kLmhhcyhIeWRyYXRpb25GZWF0dXJlS2luZC5Ob0h0dHBUcmFuc2ZlckNhY2hlKSB8fCBoYXNIdHRwVHJhbnNmZXJDYWNoZU9wdGlvbnMpID9cbiAgICAgICAgIFtdIDpcbiAgICAgICAgIMm1d2l0aEh0dHBUcmFuc2ZlckNhY2hlKHt9KSksXG4gICAgcHJvdmlkZXJzLFxuICBdKTtcbn1cbiJdfQ==